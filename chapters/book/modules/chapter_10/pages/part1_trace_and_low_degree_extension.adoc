_版权所有 © 2019 Starkware Industries Ltd。根据 Apache 许可证版本 2.0（“许可证”）许可。除非符合许可证的规定，否则您不得使用此文件。您可以在
https://www.starkware.co/open-source-license/ 获取许可证的副本。除非适用法律要求或书面同意，否则根据许可证分发的软件是基于“按原样”分发的，没有任何形式的明示或暗示的保证或条件。请参阅许可证以了解许可权限和限制的具体语言。_

== Part 1: 轨迹和低次扩展

* https://www.youtube.com/watch?v=Y0uJz9VL3Fo[视频讲解 (youtube)]
* https://starkware.co/wp-content/uploads/2021/12/STARK101-Part1.pdf[幻灯片
(PDF)]

今天我们将为有限域上的 FibonacciSq 序列开发一个 STARK 证明程序。FibonacciSq 序列由递推关系 latexmath:[a_{n+2} = a_{n+1} ^2 + a_n ^2] 定义。到最后的时候，您的代码将产生一个 _STARK_ 证明，证明以下
陈述：*我知道一个域元素 latexmath:[X\in \mathbb{F}]，由此，以 latexmath:[1, X] 开始的 FibonacciSq 序列的第1023个元素是 latexmath:[2338775057]*。

=== 基本原则

==== FieldElement class

我们使用 `+FieldElement+` 类来表示有限域上的元素。您可以使用整数构造 `+FieldElement+` 的实例，然后进行加法、乘法、除法、求逆等运算。这个类的底层域是 latexmath:[\mathbb{F}_{3221225473}]
(latexmath:[3221225473 = 3 \cdot 2^{30} + 1])，所以所有的运算都是在模 3221225473 意义下进行的。您可以通过运行以下单元格 (shift
enter) 来尝试。

[source,python]
----
从域导入 FieldElement
FieldElement(3221225472) + FieldElement(10)
----

== FibonacciSq Trace

首先，让我们构造一个长度为 1023 的列表 `+a+` ，其中前两个元素将分别表示为 1 和 3141592 的 FieldElement 对象。接下来的 1021 个元素将是由这两个元素所诱导的 FibonacciSq 序列。 `+a+` 被称为 FibonacciSq 的轨迹，或者在上下文清晰的情况下，简称为轨迹。我们按照以下方式计算 `+a+` ：

[source,python]
----
a = [FieldElement(1), FieldElement(3141592)]
while len(a) < 1023:
    a.append(a[-2] * a[-2] + a[-1] * a[-1])
----

== 测试你的代码

运行下一个单元格以测试您是否正确地填充了 `+a+`。请注意，这实际上是一个验证器，尽管它非常简单和冗长，因为它逐个元素地遍历序列，确保它是正确的。

[source,python]
----
assert len(a) == 1023, 'The trace must consist of exactly 1023 elements.'
assert a[0] == FieldElement(1), 'The first element in the trace must be the unit element.'
for i in range(2, 1023):
    assert a[i] == a[i - 1] * a[i - 1] + a[i - 2] * a[i - 2], f'The FibonacciSq recursion rule does not apply for index {i}'
assert a[1022] == FieldElement(2338775057), 'Wrong last element!'
print('Success!')
----

== 多项式的思考

现在，我们希望将这个序列视为某个未知多项式 latexmath:[f] 的 1022 阶评估结果（由于 Unisolvence 定理）。我们将选择域为某个大小为 1024 的子群 latexmath:[G \subseteq \mathbb{F}^\times]，原因稍后会变得清晰。

(回想一下，latexmath:[\mathbb{F}^\times] 表示从域 latexmath:[\mathbb{F}]中删除零元素后的乘法群。大小为 1024 的子群是存在的，因为 latexmath:[\mathbb{F}^\times] 是大小为 latexmath:[3\cdot 2^{30}]的循环群，因此它包含大小为 latexmath:[2^i] 的子群，其中 latexmath:[0 \leq i \leq 30])。

=== 找到一个大小为 1024 的群

If we find an element latexmath:[g \in \mathbb{F}] whose
(multiplicative) order is 1024, then latexmath:[g] will generate such a
group. The class `+FieldElement+` provides a static method
`+generator()+` which returns an element that generates
latexmath:[\mathbb{F}^\times] (whose order is
latexmath:[|\mathbb{F}^\times|]).

. Use it to obtain a generator latexmath:[g] for latexmath:[G].
. Create a list called `+G+` with all the elements of latexmath:[G],
such that latexmath:[G[i] := g^i].

_Hint: When latexmath:[k] divides latexmath:[|\mathbb{F}^\times|],
latexmath:[g^k] generates a group of size
latexmath:[\frac {|\mathbb{F}^\times|}{k}], and the n-th power of some
`+FieldElement+` latexmath:[x] can be computed by calling `+x ** n+`._

Solution:

[source,python]
----
g = FieldElement.generator() ** (3 * 2 ** 20)
G = [g ** i for i in range(1024)]
----

Run the next cell to test your code.

[source,python]
----
# Checks that g and G are correct.
assert g.is_order(1024), 'The generator g is of wrong order.'
b = FieldElement(1)
for i in range(1023):
    assert b == G[i], 'The i-th place in G is not equal to the i-th power of g.'
    b = b * g
    assert b != FieldElement(1), f'g is of order {i + 1}'
    
if b * g == FieldElement(1):
    print('Success!')
else:
    print('g is of order > 1024')
----

== Polynomial class

We provide you with a class called `+Polynomial+`. The simplest way to
construct a `+Polynomial+` is by using the variable `+X+` (note that
it's a capital `+X+`) which represents the formal variable
latexmath:[x]:

[source,python]
----
from polynomial import X
# The polynomial 2x^2 + 1.
p = 2*X**2 + 1
# Evaluate p at 2:
print(p(2))
----

== Interpolating a Polynomial

Our `+polynomial+` module provides a Lagrange interpolation function,
whose arguments are:

* x_values: x-values of G that the polynomial's values for them is
known. [List]
* y_values: the corresponding y-values. [List]

It returns the unique `+Polynomial+` of degree < `+len(x_values)+`
instance that evaluates to `+y_values[i]+` on `+x_values[i]+` for all i.

Run the following cell to get help on the function `+interpolate_poly+`.

[source,python]
----
from polynomial import interpolate_poly
interpolate_poly?
----

Suppose that `+a+` contains the values of some polynomial over `+G+`
(except for `+G[-1]+`, since `+a+` is one element shorter). Use
`+interpolate_poly()+` to get `+f+` and get its value at
`+FieldElement(2)+`.

Solution:

[source,python]
----
f = interpolate_poly(G[:-1], a)
v = f(2)
----

Run test:

[source,python]
----
assert v == FieldElement(1302089273)
print('Success!')
----

== Evaluating on a Larger Domain

The trace, viewed as evaluations of a polynomial latexmath:[f] on
latexmath:[G], can now be extended by evaluating latexmath:[f] over a
larger domain, thereby creating a Reed-Solomon error correction code.

=== Cosets

To that end, we must decide on a larger domain on which latexmath:[f]
will be evaluated. We will work with a domain that is 8 times larger
than latexmath:[G]. A natural choice for such a domain is to take some
group latexmath:[H] of size 8192 (which exists because 8192 divides
latexmath:[|\mathbb{F}^\times|]), and shift it by the generator of
latexmath:[\mathbb{F}^\times], thereby obtaining a
https://en.wikipedia.org/wiki/Coset[coset] of latexmath:[H].

Create a list called `+H+` of the elements of latexmath:[H], and
multiply each of them by the generator of latexmath:[\mathbb{F}^\times]
to obtain a list called `+eval_domain+`. In other words, eval_domain =
latexmath:[\{w\cdot h^i | 0 \leq i <8192 \}] for latexmath:[h] the
generator of latexmath:[H] and latexmath:[w] the generator of
latexmath:[\mathbb{F}^\times].

Hint: You already know how to obtain latexmath:[H] - similarly to the
way we got latexmath:[G] a few minutes ago.

Solution:

[source,python]
----
w = FieldElement.generator()
h = w ** ((2 ** 30 * 3) // 8192)
H = [h ** i for i in range(8192)]
eval_domain = [w * x for x in H]
----

Run test:

[source,python]
----
from hashlib import sha256
assert len(set(eval_domain)) == len(eval_domain)
w = FieldElement.generator()
w_inv = w.inverse()
assert '55fe9505f35b6d77660537f6541d441ec1bd919d03901210384c6aa1da2682ce' == sha256(str(H[1]).encode()).hexdigest(),\
    'H list is incorrect. H[1] should be h (i.e., the generator of H).'
for i in range(8192):
    assert ((w_inv * eval_domain[1]) ** i) * w == eval_domain[i]
print('Success!')
----

== Evaluate on a Coset

Time to use `+interpolate_poly+` and `+Polynomial.poly+` to evaluate
over the coset. Note that it is implemented fairely naively in our
Python module, so interpolation may take up to a minute. Indeed -
interpolating and evaluating the trace polynomial is one of the most
computationally-intensive steps in the STARK protocol, even when using
more efficient methods (e.g. FFT).

Solution:

[source,python]
----
f = interpolate_poly(G[:-1], a)
f_eval = [f(d) for d in eval_domain]
----

Run test:

[source,python]
----
# Test against a precomputed hash.
from hashlib import sha256
from channel import serialize
assert '1d357f674c27194715d1440f6a166e30855550cb8cb8efeb72827f6a1bf9b5bb' == sha256(serialize(f_eval).encode()).hexdigest()
print('Success!')
----

== Commitments

We will use https://en.wikipedia.org/wiki/SHA-2[Sha256]-based
https://en.wikipedia.org/wiki/Merkle_tree[Merkle Trees] as our
commitment scheme. A simple implementation of it is available to you in
the `+MerkleTree+` class. Run the next cell (for the sake of this
tutorial, this also serves as a test for correctness of the entire
computation so far):

[source,python]
----
from merkle import MerkleTree
f_merkle = MerkleTree(f_eval)
assert f_merkle.root == '6c266a104eeaceae93c14ad799ce595ec8c2764359d7ad1b4b7c57a4da52be04'
print('Success!')
----

== Channel

Theoretically, a STARK proof system is a protocol for interaction
between two parties - a prover and a verifier. In practice, we convert
this interactive protocol into a non-interactive proof using the
https://en.wikipedia.org/wiki/Fiat%E2%80%93Shamir_heuristic[Fiat-Shamir
Heuristic]. In this tutorial you will use the `+Channel+` class, which
implements this transformation. This channel replaces the verifier in
the sense that the prover (which you are writing) will send data, and
receive random numbers or random `+FieldElement+` instances.

This simple piece of code instantiates a channel object, sends the root
of your Merkle Tree to it. Later, the channel object can be called to
provide random numbers or random field elements.

[source,python]
----
from channel import Channel
channel = Channel()
channel.send(f_merkle.root)
----

Lastly - you can retrieve the proof-so-far (i.e., everything that was
passed in the channel up until a certain point) by printing the member
`+Channel.proof+`.

[source,python]
----
print(channel.proof)
----
